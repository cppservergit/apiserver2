global
        log /dev/log    local0
        log /dev/log    local1 notice
        chroot /var/lib/haproxy
        stats socket /run/haproxy/admin.sock mode 660 level admin
        stats timeout 30s
        user haproxy
        group haproxy
        daemon

        # Default SSL material locations
        ca-base /etc/ssl/certs
        crt-base /etc/ssl/private

        # See: https://ssl-config.mozilla.org/#server=haproxy&server-version=2.0.3&config=intermediate
        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

        # Lua settings
        tune.lua.bool-sample-conversion normal
        tune.ssl.capture-buffer-size 192
        lua-load /etc/haproxy/lua/ja4.lua

defaults
        log     global
        mode    http
        option  httplog
        option  dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
        errorfile 400 /etc/haproxy/errors/400.http
        errorfile 403 /etc/haproxy/errors/403.http
        errorfile 408 /etc/haproxy/errors/408.http
        errorfile 500 /etc/haproxy/errors/500.http
        errorfile 502 /etc/haproxy/errors/502.http
        errorfile 503 /etc/haproxy/errors/503.http
        errorfile 504 /etc/haproxy/errors/504.http

frontend apiserver2
    bind *:443 ssl crt /etc/ssl/private/haproxy.pem

    # ====================================================================
    # LOGGING & REQUEST TRACKING
    # ====================================================================
    option httplog

    # Generate a unique UUID for every request and inject it into the X-Request-ID header
    unique-id-format %[uuid()]
    unique-id-header X-Request-ID

    # Capture headers for log
    http-request capture req.hdr(User-Agent) len 64

    # Pass the client's real IP to the backend
    option forwardfor

    # Custom log format includes %ID (the UUID) at the beginning
    log-format "%ID %ci [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %CC %CS %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %hr %hs %{+Q}r %[var(txn.log_tag)]"

    # ====================================================================
    # JA4 FINGERPRINTING & BLOCKING
    # ====================================================================
    # 1. Execute the Lua script to calculate the JA4 fingerprint
    http-request lua.fingerprint_ja4

    # 2. Store the fingerprint in a variable (so we can log/check it)
    http-request set-var(txn.ja4) var(txn.fingerprint_ja4)

    # 3. Check the blacklist file
    acl is_blacklisted_ja4 var(txn.ja4) -m str -f /etc/haproxy/blacklists/ja4_blacklist.lst

    # 4. Append the JA4 hash to the log for visibility
    #    This captures the 36-char hash into the captured headers slot
    http-request capture var(txn.ja4) len 36

    # 5. Deny if blacklisted (and log a specific tag)
    http-request set-var(txn.log_tag) str("JA4_BLOCK") if is_blacklisted_ja4
    http-request deny deny_status 403 if is_blacklisted_ja4

    # ====================================================================
    # BASE SECURITY & PROTOCOL ENFORCEMENT
    # ====================================================================
    # 1. Block HTTP CONNECT method (used for tunneling/proxy abuse)
    http-request deny if { method CONNECT }

    # 2. Block Chunked Requests (Mitigates HTTP Request Smuggling)
    acl is_chunked_request hdr(transfer-encoding) -i chunked
    http-request deny deny_status 501 if is_chunked_request

    # 3. Define Path ACLs
    acl starts_with_api path_beg /api/
    acl is_login path -i /api/login
    acl is_ping  path -i /api/ping

    # 4. Drop non-/api/ traffic instantly
    http-request deny deny_status 404 if !starts_with_api

    # 5. Drop /api/ping requests, only for internal health check
    http-request set-var(txn.log_tag) str("PING_BLOCK") if is_ping
    http-request deny deny_status 404 if is_ping

    # ====================================================================
    # RATE LIMITING FOR /api/login (Brute-Force Protection)
    # ====================================================================
    # Track IPs in memory. 100k entries, 1-minute expiration, track 1-minute HTTP request rate.
    stick-table type ip size 100k expire 1m store http_req_rate(1m)

    # Track requests to the login endpoint by Source IP
    http-request track-sc0 src if is_login

    # Define abuse as more than 5 requests per minute
    acl login_abuse sc_http_req_rate(0) gt 5

    # Log and block abusive IPs with 429 Too Many Requests
    http-request set-var(txn.log_tag) str("BRUTEFORCE_BLOCK") if is_login login_abuse
    http-request deny deny_status 429 if is_login login_abuse

    # ====================================================================
    # AUTHORIZATION ENFORCEMENT
    # ====================================================================
    acl has_bearer_token req.hdr(Authorization) -i -m beg "Bearer "

    # 1. Set the custom log tag
    http-request set-var(txn.log_tag) str("UNAUTH_BLOCK") if !is_login !is_ping !has_bearer_token

    # 2. Enforce Authorization: Deny with 401 if it's not a login AND has no token
    http-request deny deny_status 401 if !is_login !has_bearer_token

    # ... route to your backend ...
    default_backend microk8s

backend microk8s
    mode http
    option httpchk GET /api/ping
    http-check expect status 200
    server node1 172.31.170.205:443 ssl verify none check inter 3s fall 3 rise 2
    server node2 172.31.162.46:443 ssl verify none check inter 3s fall 3 rise 2